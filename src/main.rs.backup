use std::fs::File;
use std::{env, fs};
use std::path::PathBuf;
use std::io;
use pcap_file::pcap::{PcapReader, PcapWriter, PcapPacket};
use pnet::packet::ethernet::{EtherTypes, EthernetPacket, EtherType};
use pnet::packet::Packet as pnet_packet;
use pnet::packet::ipv4::Ipv4Packet;
use pnet::packet::ipv6::Ipv6Packet;
use pnet::packet::udp::UdpPacket;
use pnet::packet::tcp::TcpPacket;
use pnet::packet::ip::IpNextHeaderProtocol;
use chrono::{DateTime, LocalResult, FixedOffset, TimeZone, Utc};
use std::time::UNIX_EPOCH;
use structopt::StructOpt;
use std;
use serde::Deserialize;
use regex::Regex;
use std::time::Instant;



#[derive(StructOpt)]
struct Cli {
    #[structopt(help = "Config file", short = "c", long = "config")]
    config_file: Option<String>,

    #[structopt(help = "PCAP file to parse", short = "f", long = "file", conflicts_with = "pcap_dir")]
    pcap_file: Option<std::path::PathBuf>,

    #[structopt(help = "Directory for Suricata PCAP files", short = "l", long = "pcap_dir", conflicts_with = "pcap_file")]
    pcap_dir: Option<String>,

    #[structopt(help = "Timestamp of the flow", long = "ts", conflicts_with = "no_timestamp")]
    timestamp: Option<String>,

    #[structopt(help = "Output parsed packets to screen", short = "p", long = "print")]
    output: bool,

    #[structopt(help = "IP to filter on", long = "ip", multiple = true)]
    ip: Vec<std::net::IpAddr>,

    #[structopt(help = "Source IP to filter on", long = "src_ip")]
    src_ip: Option<std::net::IpAddr>,

    #[structopt(help = "Destination IP to filter on", long = "dest_ip")]
    dest_ip: Option<std::net::IpAddr>,

    #[structopt(help = "Source port to filter on", long = "src_port")]
    src_port: Option<u16>,

    #[structopt(help = "Destination port to filter on", long = "dest_port")]
    dest_port: Option<u16>,

    #[structopt(help = "Port to filter on", long = "port", multiple = true)]
    port: Vec<u16>,

    #[structopt(help = "Log level (e.g., debug, info, warn, error)", long = "log-level")]
    log_level: Option<String>,

    #[structopt(help = "If no timestamp is given, use this flag to search all pcap files", long = "no-timestamp")]
    no_timestamp: bool,

}

#[derive(Deserialize)]
struct Config {
    log_level: Option<String>,
    pcap_directory: Option<String>,
    output_directory: Option<String>,
}

fn read_config(config_path: &str) -> Result<Config, Box<dyn std::error::Error>> {
    let config_contents = fs::read_to_string(config_path)?;
    let config: Config = toml::from_str(&config_contents)?;
    Ok(config)
}

#[derive(Debug)]
struct PcapDirError;

impl std::fmt::Display for PcapDirError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "Failed to set directory for pcap files")
    }
}

impl std::error::Error for PcapDirError {}

fn extract_timestamp_from_filename(filename: Option<&str>) -> Option<i64> {
    filename.and_then(|f| {
        let parts: Vec<&str> = f.split('-').collect();
        parts.first().and_then(|p| p.parse::<i64>().ok())
    })
}

fn extract_modified_time(file: PathBuf) -> io::Result<DateTime<Utc>> {
    let metadata = fs::metadata(file)?;
    let modified_time = metadata.modified()?;
    let datetime = DateTime::<Utc>::from(modified_time);
    Ok(datetime)
}

fn is_pcap_file(path: &PathBuf) -> bool {
    match path.extension() {
        Some(ext) => {
            let ext_str = ext.to_str().unwrap_or("").to_lowercase();
            ext_str == "pcap" || ext_str == "pcapng"
        }
        None => false,
    }
}

fn directory(path: PathBuf, time: &str) -> Result<Vec<PathBuf>, io::Error> {
    
    // set the time for the flow that is being search for
    let flow_time = time;

    // create a vector of all the possible pcap files that match the conditions
    let mut matching_files = Vec::new();

    log::info!("Searching Pcap files for a flow at {}", time);
    // Look at every file in the pcap directory
    for entry in fs::read_dir(path)? {
        log::debug!("Looking at file: {:?}", entry);
        let entry = entry?;
        // Attempt to extract the file name as a string slice
        let path_buff = entry.path();
        // If the file is a pcap file continue investigating
        if is_pcap_file(&path_buff) {
            log::debug!("{:?} is a pcap file.", &path_buff);
            let file_name_os_str = path_buff.file_name();
            let path_str = match file_name_os_str {
                Some(name) => name.to_str(),
                None => None,
            };
            // set the start and end time for the pcap file
            let last_modified = extract_modified_time(entry.path()).unwrap();
            let timestamp = extract_timestamp_from_filename(path_str);
            // if timestamp from the file name is valid
            if let Some(file_time) = timestamp {
                log::debug!("Pcap file started at {:?} and ended at {}", Utc.timestamp_opt(file_time, 0), last_modified);
                match Utc.timestamp_opt(file_time, 0) {
                    LocalResult::Single(file_time) => {
                        let flow_time: DateTime<FixedOffset> = DateTime::parse_from_rfc3339(&flow_time)
                            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, format!("The timestamp provided is not valid {}", e)))?;
                        log::debug!("Flow time: {}", flow_time);
                        let flow_time = flow_time.with_timezone(&Utc);
                        if flow_time >= file_time && flow_time <= last_modified {
                            log::debug!("{:?} matched timestamp filter", entry.path());
                            matching_files.push(entry.path())
                        } else if flow_time == Utc.timestamp_opt(0, 0).unwrap() {
                            log::debug!("{:?} matched since --no-timestamp was used", entry.path());
                            matching_files.push(entry.path())
                        }
                    }
                    _ => {
                        log::warn!("Invalid timestamp on {:?}", path_str);
                        return Err(io::Error::new(io::ErrorKind::InvalidData, "Invalid timestamp"))
                    }
                }
            } else {
                log::warn!{"Pcap file {:?} does not have a valid date format", path_buff}
            }
        } else {
            log::debug!("{:?} is not a pcap file", path_buff)
        }
    }
    log::info!("{} pcap files matched flow time filter", matching_files.len());
    Ok(matching_files)
}

fn packet_time(pcap: &PcapPacket) -> String  {
    let full_time = pcap.timestamp;
    let d = UNIX_EPOCH + full_time;
    let datetime = DateTime::<Utc>::from(d);
    let timestamp_str = datetime.format("%H:%M:%S.%6f").to_string();
    return timestamp_str;
}

fn tcp_flags(encoded_flags: u8) -> String {
    //let flags = format!("{:b}", encoded_flags);
    let mut flags: String = "".to_string();
    // Ack Flag
    if encoded_flags & (1 << 4) > 0 {
        flags.push_str(".");
    }
    // Push Flag
    if encoded_flags & (1 << 3) > 0 {
        flags.push_str("P");
    }
    // Reset Flag
    if encoded_flags & (1 << 2) > 0 {
        flags.push_str("R");
    }
    // Syn Flag
    if encoded_flags & (1 << 1) > 0 {
        flags.push_str("S");
    }
    // Fin flag
    if encoded_flags & (1 << 0) > 0 {
        flags.push_str("F");
    }
    return format!("{}", flags);
}

fn ipv4_parse(pcap: &PcapPacket, ether_packet: &EthernetPacket, args: &Cli) -> bool {
    let v4_packet = Ipv4Packet::new(ether_packet.payload()).unwrap();

    // IF IP filter is present, test if the packet contains that IP, if not return from function
        if args.ip.len() > 0 {
            for ip in &args.ip {
                if ip != &v4_packet.get_source() && ip != &v4_packet.get_destination() {
                    return false;
                }
            }
        }

        if args.src_ip.is_some() {
            if args.src_ip.unwrap() != v4_packet.get_source() && args.src_ip.unwrap() != v4_packet.get_destination() {
                return false;
            }
        }

        if args.dest_ip.is_some() {
            if args.dest_ip.unwrap() != v4_packet.get_destination() && args.dest_ip.unwrap() != v4_packet.get_source() {
                return false;
            }
        }

    match v4_packet.get_next_level_protocol() {
        IpNextHeaderProtocol(17) => {
            return udp_parse(&pcap, v4_packet, &args);
        }
        IpNextHeaderProtocol(6) => {
            return tcp_parse(&pcap, v4_packet, &args);
        }
        _ => return false,
    }
}

fn ipv6_parse(pcap: &PcapPacket, ether_packet: &EthernetPacket, args: &Cli) -> bool {
    let v6_packet = Ipv6Packet::new(ether_packet.payload()).unwrap();

    // IF IP filter is present, test if the packet  contains that IP, if not return from function
    if args.ip.len() > 0 {
        for ip in &args.ip {
            if ip != &v6_packet.get_source() && ip != &v6_packet.get_destination() {
                return false;
            }
        }
    }

    if args.src_ip.is_some() {
        if args.src_ip.unwrap() != v6_packet.get_source() && args.src_ip.unwrap() != v6_packet.get_destination() {
            return false;
        }
    }


    if args.dest_ip.is_some() {
        if args.dest_ip.unwrap() != v6_packet.get_destination() && args.dest_ip.unwrap() != v6_packet.get_source() {
            return false;
        }
    }

    match v6_packet.get_next_header() {
        IpNextHeaderProtocol(17) => {
            return udp6_parse(&pcap, v6_packet, args);
        }
        IpNextHeaderProtocol(6) => {
            return tcp6_parse(&pcap, v6_packet, args);
        }
        _ => return false,
    }
}

fn udp_parse(pcap: &PcapPacket, v4_packet: Ipv4Packet, args: &Cli) -> bool {
    let udp_packet = UdpPacket::new(&v4_packet.payload()).unwrap();

    match args.port.len() {
        1 => {
            let port = args.port[0];
            if port != udp_packet.get_source() && port != udp_packet.get_destination() {
                return false;
            }
        }
        2 => {
            let ports = [&udp_packet.get_source(), &udp_packet.get_destination()];
            if !args.port.contains(ports[0]) || !args.port.contains(ports[1]) {
                return false;
            }
        }
        _ => {
            //println!("Invalid number of ports provided");
            return false;
        }
    }

    if args.src_port.is_some() {
        if args.src_port.unwrap() != udp_packet.get_source() {
            return false
        }
    }
    if args.dest_port.is_some() {
        if args.dest_port.unwrap() != udp_packet.get_destination() {
            return false;
        }
    }

    if args.output {
        println!("{} IP {}:{} > {}:{}: udp {}", packet_time(&pcap), v4_packet.get_source(), udp_packet.get_source(), v4_packet.get_destination(), udp_packet.get_destination(), udp_packet.get_length().to_string());
    }

    return true;
}

fn tcp_parse(pcap: &PcapPacket, v4_packet: Ipv4Packet, args: &Cli) -> bool {
    let tcp_packet = TcpPacket::new(&v4_packet.payload()).unwrap();
    
    match args.port.len() {
        1 => {
            let port = args.port[0];
            if port != tcp_packet.get_source() && port != tcp_packet.get_destination() {
                return false;
            }
        }
        2 => {
            let ports = [&tcp_packet.get_source(), &tcp_packet.get_destination()];
            if !args.port.contains(ports[0]) || !args.port.contains(ports[1]) {
                return false;
            }
        }
        _ => {
            //println!("Invalid number of ports provided");
            return false;
        }
    }

    if args.src_port.is_some() {
        if args.src_port.unwrap() != tcp_packet.get_source() {
            return false;
        }
    }

    else if args.dest_port.is_some() {
        if args.dest_port.unwrap() != tcp_packet.get_destination() {
            return false;
        }
    }

    if args.output {
        println!("{} IP {}:{} > {}:{}: Flags [{}]", packet_time(&pcap), v4_packet.get_source(), tcp_packet.get_source(), v4_packet.get_destination(), tcp_packet.get_destination(), tcp_flags(tcp_packet.get_flags()));
    }

    return true;
}

fn udp6_parse(pcap: &PcapPacket, v6_packet: Ipv6Packet, args: &Cli) -> bool {
    let udp_packet = UdpPacket::new(&v6_packet.payload()).unwrap();

    match args.port.len() {
        1 => {
            let port = args.port[0];
            if port != udp_packet.get_source() && port != udp_packet.get_destination() {
                return false;
            }
        }
        2 => {
            let ports = [&udp_packet.get_source(), &udp_packet.get_destination()];
            if !args.port.contains(ports[0]) || !args.port.contains(ports[1]) {
                return false;
            }
        }
        _ => {
            //println!("Invalid number of ports provided");
            return false;
        }
    }

    if args.src_port.is_some() {
        if args.src_port.unwrap() != udp_packet.get_source() {
            return false;
        }
    }

    if args.dest_port.is_some() {
        if args.dest_port.unwrap() != udp_packet.get_destination() {
            return false;
        }
    }

    if args.output {
        println!("{} IP6 {}:{} > {}:{}: udp {}", packet_time(&pcap), v6_packet.get_source(), udp_packet.get_source(), v6_packet.get_destination(), udp_packet.get_destination(), udp_packet.get_length().to_string());
    }

    return true;
}

fn tcp6_parse(pcap: &PcapPacket, v6_packet: Ipv6Packet, args: &Cli) -> bool {
    let tcp_packet = TcpPacket::new(&v6_packet.payload()).unwrap();

    match args.port.len() {
        1 => {
            let port = args.port[0];
            if port != tcp_packet.get_source() && port != tcp_packet.get_destination() {
                return false;
            }
        }
        2 => {
            let ports = [&tcp_packet.get_source(), &tcp_packet.get_destination()];
            if !args.port.contains(ports[0]) || !args.port.contains(ports[1]) {
                return false;
            }
        }
        _ => {
            //println!("Invalid number of ports provided");
            return false;
        }
    }

    if args.src_port.is_some() {
        if args.src_port.unwrap() != tcp_packet.get_source() {
            return false;
        }
    }

    if args.dest_port.is_some() {
        if args.dest_port.unwrap() != tcp_packet.get_destination() {
            return false;
        }
    }

    if args.output {
        println!("{} IP6 {}:{} > {}:{}: Flags [{}]", packet_time(&pcap), v6_packet.get_source(), tcp_packet.get_source(), v6_packet.get_destination(), tcp_packet.get_destination(), tcp_flags(tcp_packet.get_flags()));
    }

    return true;
}

fn packet_parse(pcap: &PcapPacket, args: &Cli) -> bool {

    //Combine seconds and nanoseconds from packet to get full timestamp and print time to screen
    let mut print_output = "".to_string();
    let time_parse = packet_time(&pcap);
    print_output.push_str(&time_parse);

    let ethernet_packet = EthernetPacket::new(&pcap.data).unwrap();
    let eth_packet = ethernet_packet.get_ethertype();

    match ethernet_packet.get_ethertype() {
        EtherTypes::Ipv4 => {
            return ipv4_parse(&pcap, &ethernet_packet, args);
        }
        EtherTypes::Ipv6 => {
            return ipv6_parse(&pcap, &ethernet_packet, args);
        }
        EtherTypes::Arp => {
            print_output.push_str(&format!(" ARP: {:?}", ethernet_packet));
            return false;
        }
        EtherType(39) => {
            print_output.push_str(&format!(" STP: {:?}", ethernet_packet));
            return false;
        }
        _ => {print_output.push_str(&format!(" Unknown Type: {:?}", eth_packet)); return false;},
    }
}

fn filter_to_name(args: &Cli) -> String {

    let mut file_name = String::new();
    
    // if timestamp is valid set it as the filename, if default time do no use it
    file_name.push_str(&args.timestamp.as_ref().unwrap());
    if file_name == "1970-01-01T00:00:00Z" {
        file_name = "".to_string();
    } else {
        file_name.push_str("_");
    }

    // IP addresses
    for ip in &args.ip {
        file_name.push_str(&ip.to_string());
        file_name = file_name+"_"    
    }

    for port in &args.port {
        file_name.push_str(&port.to_string());
        file_name.push_str("_");
    }

    for ip in &args.src_ip {
        file_name.push_str("src-ip-");
        file_name.push_str(&ip.to_string());
        file_name.push_str("_");  
    }

    for port in &args.src_port {
        file_name.push_str("src-port-");
        file_name.push_str(&port.to_string());
        file_name.push_str("_");  
    }

    for ip in &args.dest_ip {
        file_name.push_str("dest-ip-");
        file_name.push_str(&ip.to_string());
        file_name.push_str("_");  
    }

    for port in &args.dest_port {
        file_name.push_str("dest-port-");
        file_name.push_str(&port.to_string());
        file_name.push_str("_");  
    }

    // Clean up trailing the filename
    file_name = file_name.trim_end_matches('_').to_string();
    file_name = file_name.replace(":", "-");
    
    // Append ".pcap" to the file name
    file_name.push_str(".pcap");

    return file_name
}

fn pcap_to_write(args: &Cli, config: &Config) -> PcapWriter<File> {


    let current_dir = env::current_dir().unwrap();
    let filtered_pcap_file = match &config.output_directory{
        Some(dir) => dir,
        None => "output"
    };

    let mut full_path = current_dir.join(filtered_pcap_file);
    log::info!("Output pcap directory: {:?}", full_path);
    
    if !full_path.exists() {
        log::error!("Output pcap directory does not exist: {:?}", full_path);
        std::process::exit(1);
    }
    
    full_path = full_path.join(filter_to_name(&args));
    log::info!("Pcap file to write {:?}", full_path);
    // Set up temp pcap file to write
    let temp_file = File::create(full_path).unwrap();
    let pcap_writer = PcapWriter::new(temp_file);
    match pcap_writer {
        Ok(pcap_writer) => return pcap_writer,
        _pcap_error => {
            log::error!("Something went wrong getting pcap file to write");
            std::process::exit(1);
        }
    }
    
}

fn validate_flow_time(flow_time: &str) -> Result<(), io::Error> {
    let re = Regex::new(r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$").unwrap();
    if !re.is_match(flow_time) {
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "Timestamp provided is not in the expected format: YYYY-MM-DDThh:mm:ss.sssZ",
        ));
    }
    Ok(())
}

fn validate_ports(ports: &[u16]) -> Result<(), std::io::Error> {
    if ports.is_empty() {
        log::error!("No port filters were given");
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            "No port filters were given",
        ));
    }
    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {

    // Set CLI argument
    let mut args = Cli::from_args();

    // Read in config file
    let config = match args.config_file {
        Some(ref file) => read_config(file),
        None => read_config("config.toml"),
    }?;

    // Determine log level from command-line arguments or configuration file
    let log_level = args.log_level
        .clone()
        .or_else(|| config.log_level.clone())
        .unwrap_or_else(|| "error".to_string());

    // set logging environment
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(&log_level)).init();

    // Validate if timestamp is valid and set to timestamp
    let timestamp = if let Some(ref ts) = args.timestamp {
        validate_flow_time(ts)?;
        ts.clone()
    } else {
        args.timestamp = Some("1970-01-01T00:00:00Z".to_string());
        "1970-01-01T00:00:00Z".to_string()
    };

    // If timestamp is not set, check if --no-timestamp flag was used
    if timestamp == "1970-01-01T00:00:00Z" && !args.no_timestamp {
        log::error!("Timestamp not set and the --no-timestamp flag was not used");
        std::process::exit(1);
    } else {
        log::warn!("No timestamp filter is set, this could take a long time...");
    }

    validate_ports(&args.port)?;

    // get pcap dir from config file, if command line argument is set give it precident
    // if neither are set try and use the current working directory
    // Determine the directory for pcap files
    let pcap_dir = args.pcap_dir
        .clone()
        .or_else(|| config.pcap_directory.clone())
        .or_else(|| env::current_dir().ok().and_then(|dir| dir.into_os_string().into_string().ok()))
        .ok_or_else(|| PcapDirError)?;

    // create pcap file to write matched packet to
    let mut pcap_writer = pcap_to_write(&args, &config);

    // If a single pcap file was provided, only search that file
    if args.pcap_file.is_some() {
        log::info!("Searching single pcap file {:?}", args.pcap_file);
        let file_name = File::open(args.pcap_file.as_ref().unwrap().as_path())?;
        let mut pcap_reader = PcapReader::new(file_name)?;
        while let Some(Ok(packet)) = pcap_reader.next_packet() {
            if packet_parse(&packet, &args) {
                pcap_writer.write_packet(&packet).unwrap();
            }
        }
    // Else search the pcap directory for all pcap files
    } else {
        let start = Instant::now();
        log::info!("Searching Pcap directory {}", pcap_dir);
        // Set the directory for pcap files as a PathBuf
        let pcap_directory = PathBuf::from(pcap_dir);
        let file_list = directory(pcap_directory, &timestamp);
        log::debug!("File to search: {:?}", file_list);
        // look at every file 
        for file in file_list.unwrap() {
            //
            let file_name = File::open(file.as_path())?;
            let mut pcap_reader = PcapReader::new(file_name)?;
            while let Some(Ok(packet)) = pcap_reader.next_packet() {
                if packet_parse(&packet, &args) {
                    pcap_writer.write_packet(&packet).unwrap();
                }
            }
        }
        let duration = start.elapsed();
        log::info!("Pcap search took: {:?} seconds", duration.as_secs_f64());
    }
    Ok(())
}
